##                                                     第一章：绪论

#### 1.1 数据结构讨论什么

Niklaus Wirth： Algorithm + Data Structures = Programs，即算法+数据结构=程序设计。

程序设计：为计算机处理问题编制的一组指令集。

算法：解决的是**怎么样**处理，即处理问题的策略

数据结构：被处理的信息在计算机中怎么表示，即问题的数学模型

**数据结构：** 数据结构描述现实世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。



#### 1.2 基本概念

- **数据：** 所有能被**输入到计算机中**，且被**计算机处理**的**符号**的集合，即计算机可操作对象的总称。含义随着计算机的发展而发展，包括数字、字符、图像、视频、声音等。

- **数据元素：** 数据中的“一个”个体，是数据结构中讨论的基本单位，但不是最小单位。

- **数据项：** 数据结构中讨论的最小单位，数据元素是数据项的集合。例如一个“学生”数据元素由姓名，学号、性别等数据项组成。

- **数据结构：** 带结构的数据元素的结合。结构是数据元素之间的约束关系。结构中先后顺序用符号<a,b>表示，表示b在a之后。

- **数据关系：** 数据关系共分为四种：线性结构、树形结构、图状结构、集合结构（例如散点图，没有关系也是一种关系）。

  

#### 1.3 数据结构的表示

**1、数据的逻辑结构：**

​               数据结构的形式定义为：数据结构是一个二元组：

```html
数据结构是一个二元组：
               Data_Structures = (D,S)
其中，D是数据元素的有限集，S是D上关系的有限集。即D表示数据元素，S表示数据元素之间的关系。
```

**2、数据的存储结构：** 逻辑结构在存储器中的表示（映象）。

- **数据元素的表示（映象）方法：** 在计算机中，用二进制位（bit）的位串表示数据元素，例如ASCII码。
- **关系的表示（映象）方法**：所有的关系都可以用**有序对<x,y>** 表示，例如一棵简单的二叉树可以表示为<a1,a2>,<a1,a3>,<a2,a4>,<a2,a5>,<a3,a6>,<a3,a7>。
- **有序对<x,y>的表示（映象）方法：** 顺序映象和链式映象。
  - 顺序映象：以存储位置的相邻来表示后继关系。y的存储位置和x的存储位置之间差一个常量C，C是一个隐含值，整个存储结构中只包含数据元素本身的信息。
  - 链式映象：又称之为非顺序映象，它是以**附加信息（指针）** 来表示后继关系。也就是说，有序对<x,y>中，x的存储是一个节点，包含两部分，一部分存储x的映象，还存储一个指向后继元素y的指针。

**3、数据的存储结构在不同编程环境中的描述：** 在高级语言中，数据的存储结构通常直接**用语言提供的数据类型** 来描述。



#### 1.4 数据类型

高级语言中的每个变量、常量和表达式等，都必须指明其所属数据类型，数据类型说明了数据元素的取值范围和允许进行的操作。

**数据类型：** 指一个值的集合和定义在此集合上的一组操作的总称，可分为简单类型和结构类型。

**数据类型和数据结构：** 数据类型可看做是一个数据结构和定义在这个数据结构上的一组操作的总称。



### 2、抽象数据类型

**抽象数据类型：** Abstract Data Type，简称ADT，是指一个数学模型以及定义在此数学模型上的一组操作。

**抽象数据类型的特征：**

- 数据的抽象性：用ADT来描述实体时，可以只考虑其本质特征、其能完成的功能以及它和外部用户的接口。
- 数据的封装性：将实体的外部特性和其内部实现细节分离，当被调用时，对外部用户隐藏其内部实现细节。

**抽象数据类型的描述方法：** 抽象数据类型可以用（D,S,P)三元组表示。其中，D是数据对象，S是D上的数据关系，P是对D的基本操作集，即数据结构（D,S)+数据操作(P)。

**抽象数据类型的表示和实现：**      

- 数据对象和数据关系的定义用伪码描述，基本操作的定义格式为：

```java
基本操作名（参数表）
    初始条件：<初始条件描述>
    操作结果：<操作结果描述>
参数：赋值参数指为操作提供输入值；引用参数以&打头，除可提供输入值外，还将返回操作结果。
初始条件：描述了操作执行之前数据结构和参数应满足的条件。若不满足，则操作失败，返回出错信息。初始条件可为空，
操作结果：描述了操作正常完成之后，数据结构的变化状况和应返回的结果。
```

- 抽象数据类型需要通过**固有数据类型** 来实现，固有数据类型是指高级语言中已经实现的数据类型。



### 3、算法和算法的度量

**算法：** 算法是为了解决某类问题而规定的一个有限长的操作序列。

**算法的特征：**

- **有穷性：** 算法的执行步骤有限；每一步执行步骤所需执行时间有限。这里的有限不是数学意义上的有限，是指其为合理的。
- **确定性:** 对于每种输入，算法中都有确切的规定；在任何条件下，算法都只有一条执行路径。即相同的输入，不管计算几次，都会产生相同的结果。
- **可行性：** 所有的操作都必须足够基本，可以通过已经实现的基本操作运算有限次实现这些基本操作。
- **有输入**
- **有输出**

**算法设计的原则：**

- **正确性**：应当满足用户特定的需要（边界条件、空值和例外值）。分为四个层次，通常第三条作为衡量一个算法是否合格的标准：
          1. 程序不含语法错误
             2. 程序对于几组输入能够得到满足要求的结果
             3. 程序对于精心选择的、典型的、苛刻且带有刁难性质的几组输入，能够得出满足要求的结果
             4. 程序对于一切合法输入，能够得到满足要求的结果

- **可读性**

- **健壮性：** 当输入的数据非法时，算法应当进行相应处理。处理的方法不应该是中断程序的执行，而应该是返回一个表示错误的值或异常。

- **高效率与低存储两需求 ：** 效率是指算法执行时间；存储量是指算法执行过程中所需的最大存储空间。都与问题规模有关。

  

### 4、算法效率的衡量方法和准则

**衡量算法效率的方法：**

- **事后统计法**：将算法编制成程序，实际跑起来，就可以知道执行时间。
- **事前分析估算法**：和算法执行时间相关的因素有：
  - **算法选用的策略**
  - **问题的规模**
  - 编程语言
  - 编译器编译后产生的机器代码的质量
  - 计算机执行指令的速度

后三项依赖于硬件和软件，我们不考虑，而只考虑算法本身。因此，一个特定算法的“运行时间”的大小，只依赖于问题的规模。或者说，**运行时间是问题规模的函数**。

#### 4.1、渐近时间复杂度

假如，随着时间规模n的增长，算法执行时间的增长率和f(n)的增长率相同，则可记做：
$$
T(n) = O(f(n))
$$
称T(n)为算法的（渐近）时间复杂度。

#### **4.2、时间复杂度的估算**

算法 = 控制结构 + 元操作（元操作可视为高级语言中固有数据类型的操作，例如相加，数据交换等）
$$
算法的执行时间 = \sum元操作（i）的执行次数\times元操作（i）的执行时间
$$
元操作的执行时间对于不同算法来说，为定值。因此，估算时间复杂度，我们一般只考虑元操作的执行次数之和。

在一个算法中，占据主要执行次数的元操作称之为**基本操作**。因此，估算时间复杂度，我们以**该基本操作在算法中重复执行的次数**，作为算法运行时间的衡量准则。

一个估算时间复杂度的例子：

选择  排序方法：

```java
void select_sort(int[] array) {
    //这个算法的作用是：将数组中的整数序列重新排列为自小到大有序的整数序列
    int n = array.length;
    for (int i=0;i<n-1;i++) {
        j=i;//j为我们设定当前循环的最小值，先从i=0开始
        for (int k=i+1;k<n;++k) {
            if (a[k]<a[j]) 
                j=k;//相邻的数逐次比较，较小值赋给a[j]，此操作可看做基本操作
        }
        if (j!=i)
            swap(a[j],a[i])//得到这一次循环的最小值，若下标不是i，则两数值交换位置
    }
}//时间复杂度为O(n^2)
```

  冒泡排序方法：

```java
void bubble_sort(int[] array) {
    //这个算法的作用是：将数组中的整数序列重新排列为自小到大有序的整数序列
    int n = array.length;
    for (int i=n-1,boolean change=true;i>1&&change;--i) {
        change = false;//每一次重新开始排序，change设置为false
        for (int j=0;j<i;++j) {
            if (a[j]>a[j+1]) {
                swap(a[j],a[j+1]);//此操作可看做基本操作
                change = true;//每一次循环比较，若存在一对前面大于后面的，change就会改变回true
            }
        }    
    }
}//时间复杂度为O(n^2)
```

我们估算时间复杂度时，一般指的是最坏情况下的时间复杂度。

### 5、算法的存储空间需求估算

**算法的空间复杂度：**
$$
S(n) = O(g(n))
$$
随着问题规模的增大，算法运行所需存储量的增长率与g(n)的增长率相同。

**算法的存储量包括：**

- 输入数据所占空间：一般来说，与问题规模无关，各个算法差不多
- 程序本身所占空间：与机器和语言有关，不占主要
- **辅助变量所占空间**

若输入数据所展空间只取决于问题本身，和算法无关，则只需要分析除输入数据和程序本身之外的辅助变量所占的额外空间。

**原地工作：** 若所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作，空间复杂度为O(1)。例如上面的排序方法。

我们估算空间复杂度时，一般指的是最坏情况下的空间复杂度。

